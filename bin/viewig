#! /usr/bin/env node

// src/cli.ts
import { Option, program } from "commander";

// src/lib.ts
import path from "path";
import FastGlob from "fast-glob";
import { readFileSync } from "fs";
import ignore from "ignore";
import { execSync } from "child_process";
var Looker = class {
  constructor(options) {
    this.negated = options?.negated ?? false;
    this.ignoreInstance = ignore.default(options);
  }
  negate() {
    this.negated = !this.negated;
    return this;
  }
  add(pattern) {
    this.ignoreInstance.add(pattern);
  }
  ignores(path3) {
    const normalPath = typeof path3 === "string" ? path3 : path3.join("\n");
    const ignores = this.ignoreInstance.ignores(normalPath);
    return this.negated ? !ignores : ignores;
  }
  isValidPattern(pattern) {
    return ignore.default.isPathValid(pattern);
  }
};
function findFiles(pattern, cwd, ignore2) {
  const paths = FastGlob.sync(pattern, { cwd, ignore: ignore2, onlyFiles: true, dot: true });
  return paths;
}
function closestFilePath(filePath, paths) {
  const filePathDir = path.dirname(filePath);
  const result = paths.reverse().find((p) => {
    const pd = path.dirname(p);
    const result2 = filePathDir.startsWith(pd) || pd === ".";
    return result2;
  });
  return result;
}
function gitConfigString(prop, cwd) {
  try {
    return execSync(`git config ${prop}`, { cwd }).toString();
  } catch (error) {
    return;
  }
}
function gitConfigBool(prop, cwd) {
  const str = gitConfigString(prop, cwd);
  if (str === "true\n") {
    return true;
  }
  if (str === "false\n") {
    return false;
  }
}
function lookFile(filePath, options) {
  const {
    cwd = process.cwd(),
    hidePattern = [],
    addPattern = [],
    sources,
    allowRelativePaths = true
  } = options;
  const ignoreCase = gitConfigBool("core.ignoreCase") ?? false;
  const looker = new Looker({
    allowRelativePaths,
    ignoreCase
  });
  for (const [pattern, method] of sources) {
    const possibleSourcePaths = findFiles(pattern, cwd, hidePattern);
    const sourcePath = closestFilePath(filePath, possibleSourcePaths);
    if (sourcePath === void 0) {
      continue;
    }
    const sourceContent = readFileSync(path.join(cwd, sourcePath)).toString();
    const isGoodSource = method({
      source: sourcePath,
      sourceContent,
      target: filePath,
      looker
    });
    if (isGoodSource) {
      looker.add(addPattern);
      return looker;
    }
  }
}
var filterNameList = ["ignored", "included", "all"];
function processPath(somePath, matches, resultList, options, cache, cwd, ignore2, filter) {
  const sourcePath = closestFilePath(somePath, matches);
  if (sourcePath === void 0) {
    return false;
  }
  let looker = cache.get(sourcePath);
  if (looker === void 0) {
    looker = lookFile(somePath, options);
    if (looker === void 0) {
      return false;
    }
    cache.set(sourcePath, looker);
  }
  const isIgnored = looker.ignores(somePath);
  const filterIgnore = filter === "ignored" && isIgnored;
  const filterInclude = filter === "included" && !isIgnored;
  const filterAll = filter === "all";
  if (filterIgnore || filterInclude || filterAll) {
    resultList.push({
      ignored: isIgnored,
      path: somePath,
      source: sourcePath,
      toString() {
        return `${this.path}`;
      }
    });
  }
  return true;
}
function lookProjectSync(options) {
  const { sources, cwd = process.cwd(), hidePattern = [], filter = "included", deep, markDirectories } = options;
  const cache = /* @__PURE__ */ new Map();
  const resultList = [];
  const allPaths = FastGlob.sync(
    "**",
    {
      cwd: options.cwd,
      dot: true,
      ignore: hidePattern,
      onlyFiles: true,
      deep,
      markDirectories
    }
  );
  for (const [pattern] of sources) {
    const matches = findFiles(pattern, cwd, hidePattern);
    let isGoodSource = false;
    for (const somePath of allPaths) {
      isGoodSource = processPath(somePath, matches, resultList, options, cache, cwd, hidePattern, filter);
    }
    if (isGoodSource) {
      break;
    }
  }
  return resultList;
}

// src/presets.ts
import getValue from "get-value";

// src/styles.ts
import { stdout } from "process";
import { default as tree } from "treeify";
import jsonifyPaths from "jsonify-paths";
var styleNameList = ["tree", "paths", "treeEmoji", "treeNerd"];
function prefixIgn(f) {
  return (f.ignored ? "!" : "+") + f.toString();
}
function chalkIgn(f, oc) {
  return (f.ignored ? oc.red : oc.green)(prefixIgn(f));
}
var Styles = {
  paths(oc, files) {
    stdout.write(files.map(
      (f) => `${chalkIgn(f, oc)}`
    ).join("\n") + "\n");
  },
  tree(oc, files) {
    const pathsAsObject = jsonifyPaths.from(files.map((f) => f.toString()), { delimiter: "/" });
    const pathsAsTree = tree.asTree(pathsAsObject, true, true);
    stdout.write(pathsAsTree);
  },
  treeEmoji(oc, files) {
    const pathsAsObject = jsonifyPaths.from(files.map((f) => f.toString()), { delimiter: "/" });
    (function walk(tree2) {
      for (const [key, value] of Object.entries(tree2)) {
        if (typeof value === "object") {
          walk(value);
        }
        const icon = (Object.keys(value).length ? "\u{1F4C2}" : "\u{1F4C4}") + " ";
        Object.defineProperty(
          tree2,
          icon + key,
          Object.getOwnPropertyDescriptor(tree2, key)
        );
        delete tree2[key];
      }
    })(pathsAsObject);
    const pathsAsTree = tree.asTree(pathsAsObject, true, true);
    stdout.write(pathsAsTree);
  },
  treeNerd(oc, files) {
    const pathsAsObject = jsonifyPaths.from(files.map((f) => f.toString()), { delimiter: "/" });
    (function walk(tree2) {
      for (const [key, value] of Object.entries(tree2)) {
        if (typeof value === "object") {
          walk(value);
        }
        const icon = (Object.keys(value).length ? "\uF115" : "\uF016") + " ";
        Object.defineProperty(
          tree2,
          icon + key,
          Object.getOwnPropertyDescriptor(tree2, key)
        );
        delete tree2[key];
      }
    })(pathsAsObject);
    const pathsAsTree = tree.asTree(pathsAsObject, true, true);
    stdout.write(pathsAsTree);
  }
};

// src/presets.ts
var presetNameList = ["git", "npm", "yarn", "vscodeExtension"];
var patternsExclude = [
  ".git/**",
  "node_modules/**",
  ".DS_Store/**"
];
var npmPatternExclude = [
  ".*.swp",
  "._*",
  ".DS_Store",
  ".git",
  ".gitignore",
  ".hg",
  ".npmignore",
  ".npmrc",
  ".lock-wscript",
  ".svn",
  ".wafpickle-*",
  "config.gypi",
  "CVS",
  "npm-debug.log"
];
var npmPatternInclude = [
  "bin/",
  "package.json",
  "README",
  "README.*",
  "LICENSE",
  "LICENSE.*",
  "LICENCE",
  "LICENCE.*"
];
var parserJSONDict = (text) => {
  try {
    const result = JSON.parse(text);
    const isDict = typeof result === "object" && result !== null && !Array.isArray(result);
    if (!isDict) throw new Error(`JSON is not dictionary`);
    return result;
  } catch (error) {
    return;
  }
};
function superPresetLookOptions(looker, options) {
  const { negate = false } = options ?? {};
  looker.negated = negate;
}
var lookProperty = (options) => {
  const { parserFunc = parserJSONDict, prop } = options;
  return function(data) {
    const { looker, sourceContent } = data;
    const parsed = parserFunc(sourceContent);
    if (!parsed) {
      return false;
    }
    const propVal = getValue(parsed, prop);
    if (!Array.isArray(propVal)) {
      return false;
    }
    superPresetLookOptions(looker, options);
    looker.add(propVal);
    return true;
  };
};
var lookGit = (options) => {
  return function(data) {
    const { looker, sourceContent } = data;
    if (!looker.isValidPattern(sourceContent)) {
      return false;
    }
    superPresetLookOptions(looker, options);
    looker.add(sourceContent);
    return true;
  };
};
function GetPresets(style, oc) {
  const IsNerd = style.toLowerCase().includes("nerd");
  return {
    // git ls-tree -r main --name-only
    git: {
      name: `${IsNerd ? oc.redBright("\uE65D") + " " : ""}Git`,
      allowRelativePaths: false,
      hidePattern: patternsExclude.concat([gitConfigString("core.excludesFile") ?? ""]),
      sources: [
        ["**/.gitignore", lookGit()]
      ]
    },
    // npm pack --dry-run
    npm: {
      name: `${IsNerd ? oc.red("\uE616") + " " : ""}NPM`,
      hidePattern: patternsExclude.concat(npmPatternExclude),
      addPattern: npmPatternInclude,
      sources: [
        ["**/package.json", lookProperty({ prop: "files", negate: true })],
        ["**/.npmignore", lookGit()],
        ["**/.gitignore", lookGit()]
      ]
    },
    yarn: {
      name: `${IsNerd ? oc.magenta("\uE6A7") + " " : ""}Yarn`,
      hidePattern: patternsExclude.concat(npmPatternExclude),
      addPattern: npmPatternInclude,
      sources: [
        ["**/package.json", lookProperty({ prop: "files", negate: true })],
        ["**/.yarnignore", lookGit()],
        ["**/.npmignore", lookGit()],
        ["**/.gitignore", lookGit()]
      ]
    },
    vscodeExtension: {
      name: `${IsNerd ? oc.red("\u{F0A1E}") + " " : ""}Visual Studio: Code - Extension`,
      hidePattern: patternsExclude,
      sources: [
        ["**/.vscodeignore", lookGit()],
        ["**/.gitignore", lookGit()]
      ]
    }
  };
}

// src/sorting.ts
import path2 from "path";
var sortNameList = ["firstFolders", "firstFiles", "type", "mixed", "modified"];
function slicePath(p) {
  const slashIndex = p.indexOf("/");
  const next = p.substring(0, slashIndex);
  const other = p.substring(slashIndex + 1);
  const isLast = next === "" && p.lastIndexOf("/") === slashIndex;
  return [slashIndex < 0 ? other : next, other, isLast];
}
var Sorters = {
  /**
   * Files and folders are sorted by their names.
   * Folders are displayed before files.
   */
  firstFolders(a, b) {
    let comp = 0;
    let next1, others1, next2, others2, last1, last2;
    for (; comp === 0; ) {
      [next1, others1, last1] = slicePath(a);
      a = others1;
      [next2, others2, last2] = slicePath(b);
      b = others2;
      comp = Sorters.mixed(next1, next2);
      if (last1 || last2) {
        if (last1 === last2) {
          break;
        }
        if (last1 === false) {
          return -1;
        }
        return 1;
      }
    }
    return comp;
  },
  /**
   * Files and folders are sorted by their names.
   * Files are displayed before folders.
   */
  firstFiles(a, b) {
    let comp = 0;
    let next1, others1, next2, others2, last1, last2;
    for (; comp === 0; ) {
      [next1, others1, last1] = slicePath(a);
      a = others1;
      [next2, others2, last2] = slicePath(b);
      b = others2;
      comp = Sorters.mixed(next1, next2);
      if (last1 || last2) {
        if (last1 === last2) {
          break;
        }
        if (last1 === true) {
          return -1;
        }
        return 1;
      }
    }
    return comp;
  },
  /**
   * Files and folders are sorted by last modified date in descending order.
   * Folders are displayed before files.
   */
  modified(a, b, aDate, bDate) {
    let comp = 0;
    let others1, others2, last1, last2;
    for (; comp === 0; ) {
      [, others1, last1] = slicePath(a);
      a = others1;
      [, others2, last2] = slicePath(b);
      b = others2;
      comp = aDate.getTime() - bDate.getTime();
      if (last1 || last2) {
        if (last1 === last2) {
          break;
        }
        if (last1 === false) {
          return -1;
        }
        return 1;
      }
    }
    return comp;
  },
  /**
   * Files and folders are grouped by extension type then sorted by thir names.
   * Folders are displayed before files.
   */
  type(a, b) {
    let comp = 0;
    let next1, others1, next2, others2, last1, last2;
    for (; comp === 0; ) {
      [next1, others1, last1] = slicePath(a);
      a = others1;
      [next2, others2, last2] = slicePath(b);
      b = others2;
      const ppa = path2.parse(next1);
      const ppb = path2.parse(next2);
      comp = Sorters.mixed(ppa.ext, ppb.ext) || Sorters.mixed(ppa.name, ppb.name);
      if (last1 || last2) {
        if (last1 === last2) {
          break;
        }
        if (last1 === false) {
          return -1;
        }
        return 1;
      }
    }
    return comp;
  },
  /**
   * Files and folders are sorted by their names.
   * Files are interwoven with folders.
   */
  mixed(a, b) {
    return a.localeCompare(b, void 0, { ignorePunctuation: false });
  }
};

// src/cli.ts
import { stdout as stdout2 } from "process";
import { Chalk } from "chalk";
import fs from "fs";
var checkCommandHelp = {
  git: "git ls-tree -r <branch name: main/master/...> --name-only",
  npm: "npm pack --dry-run",
  vscodeExtension: "vsce ls"
};
function safetyHelpCreate(target) {
  const command = checkCommandHelp[target] ?? "";
  if (command === "") {
    return "";
  }
  return `

You can use the \`${command}\` command to check if the list is valid.`;
}
function print(options) {
  const start = Date.now();
  options.target ??= "git";
  options.filter ??= "included";
  options.sort ??= "firstFolders";
  options.style ||= "tree";
  const colorLevel = Math.max(0, Math.min(Number(options.color ?? 3), 3));
  const oc = new Chalk({ level: colorLevel });
  const isNerd = options.style.toLowerCase().includes("nerd");
  const isEmoji = options.style.toLowerCase().includes("emoji");
  const preset = GetPresets(options.style, oc)[options.target];
  const looked = lookProjectSync({
    ...preset,
    filter: options.filter
  });
  const sorter = Sorters[options.sort];
  const cacheEditDates = /* @__PURE__ */ new Map();
  for (const look of looked) {
    cacheEditDates.set(look, fs.statSync(look.path).mtime);
  }
  const lookedSorted = looked.sort((a, b) => sorter(
    a.toString(),
    b.toString(),
    cacheEditDates.get(a),
    cacheEditDates.get(b)
  ));
  stdout2.write((isNerd ? "\uF115 " : "") + process.cwd() + "\n");
  Styles[options.style](oc, lookedSorted, options.style, options.filter);
  const time = Date.now() - start;
  stdout2.write(`
`);
  stdout2.write(`${isEmoji ? "\u2714\uFE0F " : isNerd ? oc.green("\uF00C ") : ""}Done in ${isNerd && time < 400 ? oc.yellow("\u{F140C}") : ""}${time}ms.`);
  stdout2.write(`

`);
  stdout2.write(`${looked.length} files listed for ${preset.name} (${options.filter}).`);
  stdout2.write(safetyHelpCreate(options.target));
  stdout2.write(`
`);
}
program.addOption(new Option("-clr, --color <level>").default(3).choices(["1", "2", "3", "4"])).addOption(new Option("-t, --target <ignorer>").default("git").choices(presetNameList)).addOption(new Option("-fl, --filter <filter>").default("included").choices(filterNameList)).addOption(new Option("-sr, --sort <sorter>").default("firstFolders").choices(sortNameList)).addOption(new Option("-st, --style <style>").default("tree").choices(styleNameList)).action(print);
var cfgProgram = program.command("cfg");

// src/bin.ts
program.parse();
